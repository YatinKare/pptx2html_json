"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var index_exports = {};
__export(index_exports, {
  AudioPartSchema: () => AudioPartSchema,
  BaseContextSchema: () => BaseContextSchema,
  ErrorSchema: () => ErrorSchema,
  FileRefPartSchema: () => FileRefPartSchema,
  ImagePartSchema: () => ImagePartSchema,
  JsonPartSchema: () => JsonPartSchema,
  PartSchema: () => PartSchema,
  TextPartSchema: () => TextPartSchema,
  audioPart: () => audioPart,
  defineTool: () => defineTool,
  fileRefPart: () => fileRefPart,
  imagePart: () => imagePart,
  isAudioPart: () => isAudioPart,
  isFileRefPart: () => isFileRefPart,
  isImagePart: () => isImagePart,
  isJsonPart: () => isJsonPart,
  isTextPart: () => isTextPart,
  jsonPart: () => jsonPart,
  mapWhen: () => mapWhen,
  textPart: () => textPart,
  validateAndResolvePath: () => validateAndResolvePath,
  when: () => when
});
module.exports = __toCommonJS(index_exports);
var import_node_path = __toESM(require("path"), 1);
var import_zod = require("zod");

// src/defineTool.ts
function defineTool(definition) {
  const wrappedExecute = async (params) => {
    const originalParts = await definition.execute({ context: params.context, args: params.args });
    return originalParts;
  };
  return {
    name: definition.name,
    description: definition.description,
    inputSchema: definition.inputSchema,
    contextSchema: definition.contextSchema,
    // Pass contextSchema through
    execute: wrappedExecute
    // Use the wrapped function
  };
}

// src/typeGuards.ts
function isTextPart(part) {
  return part.type === "text";
}
function isJsonPart(part) {
  return part.type === "json";
}
function isImagePart(part) {
  return part.type === "image";
}
function isAudioPart(part) {
  return part.type === "audio";
}
function isFileRefPart(part) {
  return part.type === "fileRef";
}
function when(part, mapper) {
  if (isTextPart(part)) {
    if (mapper.text) return mapper.text(part);
    throw new Error(`Handler for part type 'text' not found in mapper`);
  }
  if (isJsonPart(part)) {
    if (mapper.json) return mapper.json(part);
    throw new Error(`Handler for part type 'json' not found in mapper`);
  }
  if (isImagePart(part)) {
    if (mapper.image) return mapper.image(part);
    throw new Error(`Handler for part type 'image' not found in mapper`);
  }
  if (isAudioPart(part)) {
    if (mapper.audio) return mapper.audio(part);
    throw new Error(`Handler for part type 'audio' not found in mapper`);
  }
  if (isFileRefPart(part)) {
    if (mapper.fileRef) return mapper.fileRef(part);
    throw new Error(`Handler for part type 'fileRef' not found in mapper`);
  }
  throw new Error(`Unhandled part type: ${part.type}`);
}
function mapWhen(parts, mapper) {
  const results = [];
  for (const part of parts) {
    let result;
    if (isTextPart(part) && mapper.text) {
      result = mapper.text(part);
    } else if (isJsonPart(part) && mapper.json) {
      result = mapper.json(part);
    } else if (isImagePart(part) && mapper.image) {
      result = mapper.image(part);
    } else if (isAudioPart(part) && mapper.audio) {
      result = mapper.audio(part);
    } else if (isFileRefPart(part) && mapper.fileRef) {
      result = mapper.fileRef(part);
    }
    if (result !== void 0) {
      results.push(result);
    }
  }
  return results;
}

// src/index.ts
var TextPartSchema = import_zod.z.object({ type: import_zod.z.literal("text"), value: import_zod.z.string() });
var JsonPartSchema = import_zod.z.object({
  type: import_zod.z.literal("json"),
  value: import_zod.z.any(),
  schema: import_zod.z.any().refine((val) => val instanceof import_zod.z.ZodType, { message: "Schema must be a Zod schema instance" })
});
var ImagePartSchema = import_zod.z.object({
  type: import_zod.z.literal("image"),
  data: import_zod.z.string(),
  mimeType: import_zod.z.string()
});
var AudioPartSchema = import_zod.z.object({
  type: import_zod.z.literal("audio"),
  data: import_zod.z.string(),
  mimeType: import_zod.z.string()
});
var FileRefPartSchema = import_zod.z.object({
  type: import_zod.z.literal("fileRef"),
  path: import_zod.z.string(),
  mimeType: import_zod.z.string().optional()
});
var PartSchema = import_zod.z.union([
  TextPartSchema,
  JsonPartSchema,
  ImagePartSchema,
  AudioPartSchema,
  FileRefPartSchema
]);
var ErrorSchema = import_zod.z.object({
  message: import_zod.z.string(),
  suggestion: import_zod.z.string().optional()
});
var BaseContextSchema = import_zod.z.object({
  allowOutsideWorkspace: import_zod.z.boolean().optional(),
  maxOutputChars: import_zod.z.number().int().positive().optional(),
  workspaceRoot: import_zod.z.string()
  // Add other base context properties as needed, mirroring ToolExecuteOptions
  // Ensure this stays in sync with ToolExecuteOptions interface
});
function validateAndResolvePath(relativePathInput, workspaceRoot, allowOutsideRoot = false) {
  if (!relativePathInput || relativePathInput.trim() === "") {
    return {
      error: "Path validation failed: Input path cannot be empty.",
      suggestion: "Provide a valid relative path."
    };
  }
  try {
    if (!allowOutsideRoot && import_node_path.default.isAbsolute(relativePathInput)) {
      return {
        error: `Path validation failed: Absolute paths are not allowed. Path: '${relativePathInput}'`,
        suggestion: "Provide a path relative to the workspace root."
      };
    }
    const resolvedPath = import_node_path.default.resolve(workspaceRoot, relativePathInput);
    const relativeToRoot = import_node_path.default.relative(workspaceRoot, resolvedPath);
    if (!allowOutsideRoot) {
      if (!allowOutsideRoot && (relativeToRoot.startsWith("..") || import_node_path.default.isAbsolute(relativeToRoot))) {
        return {
          error: `Path validation failed: Path must resolve within the workspace root ('${workspaceRoot}'). Relative Path: '${relativeToRoot}'`,
          suggestion: `Ensure the path '${relativePathInput}' is relative to the workspace root and does not attempt to go outside it.`
        };
      }
    }
    return resolvedPath;
  } catch (e) {
    const errorMsg = e instanceof Error ? e.message : "Unknown error";
    return {
      error: `Path resolution failed for '${relativePathInput}': ${errorMsg}`,
      suggestion: "Ensure the provided path is valid."
    };
  }
}
function textPart(value) {
  return { type: "text", value };
}
function jsonPart(value, schema) {
  return { type: "json", value, schema };
}
function imagePart(data, mimeType) {
  return { type: "image", data, mimeType };
}
function audioPart(data, mimeType) {
  return { type: "audio", data, mimeType };
}
function fileRefPart(path2, mimeType) {
  return { type: "fileRef", path: path2, mimeType };
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  AudioPartSchema,
  BaseContextSchema,
  ErrorSchema,
  FileRefPartSchema,
  ImagePartSchema,
  JsonPartSchema,
  PartSchema,
  TextPartSchema,
  audioPart,
  defineTool,
  fileRefPart,
  imagePart,
  isAudioPart,
  isFileRefPart,
  isImagePart,
  isJsonPart,
  isTextPart,
  jsonPart,
  mapWhen,
  textPart,
  validateAndResolvePath,
  when
});
//# sourceMappingURL=index.cjs.map