{"version":3,"sources":["../src/index.ts","../src/defineTool.ts","../src/typeGuards.ts"],"sourcesContent":["import path from 'node:path';\n// src/index.ts for @sylphlab/mcp-core\nimport { type ZodTypeAny, z } from 'zod'; // Import z and ZodTypeAny\n\nexport const TextPartSchema = z.object({ type: z.literal('text'), value: z.string() });\nexport type TextPart = z.infer<typeof TextPartSchema>;\n\n// For JsonPart schema: value is any, schema is any (as Zod schema objects aren't easily serializable/representable in Zod itself)\n// Type safety relies on the tool implementation using the correct schema provided during definition.\nexport const JsonPartSchema = z.object({\n  type: z.literal('json'),\n  value: z.any(),\n  schema: z\n    .any()\n    .refine((val) => val instanceof z.ZodType, { message: 'Schema must be a Zod schema instance' }),\n}); // Use z.ZodType\n// Generic type for implementation, using z.any() for the schema's schema part\nexport type JsonPart<T extends ZodTypeAny = ZodTypeAny> = {\n  type: 'json';\n  value: z.infer<T>;\n  schema: T;\n};\n\nexport const ImagePartSchema = z.object({\n  type: z.literal('image'),\n  data: z.string(),\n  mimeType: z.string(),\n});\nexport type ImagePart = z.infer<typeof ImagePartSchema>;\n\nexport const AudioPartSchema = z.object({\n  type: z.literal('audio'),\n  data: z.string(),\n  mimeType: z.string(),\n});\nexport type AudioPart = z.infer<typeof AudioPartSchema>;\n\nexport const FileRefPartSchema = z.object({\n  type: z.literal('fileRef'),\n  path: z.string(),\n  mimeType: z.string().optional(),\n});\nexport type FileRefPart = z.infer<typeof FileRefPartSchema>;\n\n// Union schema for internal parts\nexport const PartSchema = z.union([\n  TextPartSchema,\n  JsonPartSchema,\n  ImagePartSchema,\n  AudioPartSchema,\n  FileRefPartSchema,\n]);\nexport type Part = z.infer<typeof PartSchema>;\n\n// Schema for the dedicated error object\nexport const ErrorSchema = z.object({\n  message: z.string(),\n  suggestion: z.string().optional(),\n});\nexport type Error = z.infer<typeof ErrorSchema>;\n\n// z is already imported at the top\n\n/** Options passed internally to the tool's execute function by the server */\nexport interface ToolExecuteOptions {\n  /** If true, allows the tool to access paths outside the workspace root. Defaults to false. */\n  allowOutsideWorkspace?: boolean;\n  /** Optional limit on the total character count of the tool's output content. */\n  maxOutputChars?: number;\n  /** The absolute path to the workspace root directory. */\n  workspaceRoot: string;\n  // Add other internal options as needed\n}\n\n/**\n * Base Zod schema corresponding to ToolExecuteOptions.\n * This serves as the default context schema for tools.\n */\nexport const BaseContextSchema = z.object({\n  allowOutsideWorkspace: z.boolean().optional(),\n  maxOutputChars: z.number().int().positive().optional(),\n  workspaceRoot: z.string(),\n  // Add other base context properties as needed, mirroring ToolExecuteOptions\n  // Ensure this stays in sync with ToolExecuteOptions interface\n});\nexport type BaseContext = z.infer<typeof BaseContextSchema>;\n\n\n// --- Path Validation Utility ---\n\nexport interface PathValidationError {\n  error: string;\n  suggestion: string;\n}\n\n/**\n * Resolves a relative path against the workspace root and validates it.\n * By default, prevents resolving paths outside the workspace root.\n *\n * @param relativePathInput The relative path input by the user/tool.\n * @param workspaceRoot The absolute path to the workspace root.\n * @param allowOutsideRoot If true, allows paths outside the workspace root. Defaults to false.\n * @returns The resolved absolute path (string) if valid, or a PathValidationError object if invalid.\n */\nexport function validateAndResolvePath(\n  relativePathInput: string,\n  workspaceRoot: string,\n  allowOutsideRoot = false,\n): string | PathValidationError {\n  // Add check for empty input path\n  if (!relativePathInput || relativePathInput.trim() === '') {\n      return {\n          error: 'Path validation failed: Input path cannot be empty.',\n          suggestion: 'Provide a valid relative path.',\n      };\n  }\n\n  try {\n    // Basic check for absolute paths if not allowed outside\n    if (!allowOutsideRoot && path.isAbsolute(relativePathInput)) {\n      return {\n        error: `Path validation failed: Absolute paths are not allowed. Path: '${relativePathInput}'`,\n        suggestion: 'Provide a path relative to the workspace root.',\n      };\n    }\n\n    const resolvedPath = path.resolve(workspaceRoot, relativePathInput);\n    const relativeToRoot = path.relative(workspaceRoot, resolvedPath);\n\n    // Only perform the relative path check if allowOutsideRoot is false\n    if (!allowOutsideRoot) {\n      if (\n        !allowOutsideRoot &&\n        (relativeToRoot.startsWith('..') || path.isAbsolute(relativeToRoot))\n      ) {\n        return {\n          error: `Path validation failed: Path must resolve within the workspace root ('${workspaceRoot}'). Relative Path: '${relativeToRoot}'`,\n          suggestion: `Ensure the path '${relativePathInput}' is relative to the workspace root and does not attempt to go outside it.`,\n        };\n      }\n    }\n\n    // Path is valid\n    return resolvedPath;\n  } catch (e: unknown) {\n    // Catch potential errors from path functions themselves\n    const errorMsg = e instanceof Error ? e.message : 'Unknown error';\n    return {\n      error: `Path resolution failed for '${relativePathInput}': ${errorMsg}`,\n      suggestion: 'Ensure the provided path is valid.',\n    };\n  }\n}\n\n// PathValidationError is already exported via `export interface`\n// ToolExecuteOptions is already exported via `export interface`\n\n// --- Part Helper Functions ---\n\nexport function textPart(value: string): TextPart {\n  return { type: 'text', value };\n}\n\nexport function jsonPart<T extends ZodTypeAny>(value: z.infer<T>, schema: T): JsonPart<T> {\n  // Basic check, full validation might happen in defineTool or adapter\n  // const validation = schema.safeParse(value);\n  // if (!validation.success) {\n  //   console.warn(\"JSON part value does not match provided schema during creation:\", validation.error);\n  //   // Decide how to handle - throw? return error part? For now, allow potentially invalid value.\n  // }\n  return { type: 'json', value, schema };\n}\n\nexport function imagePart(data: string, mimeType: string): ImagePart {\n  return { type: 'image', data, mimeType };\n}\n\nexport function audioPart(data: string, mimeType: string): AudioPart {\n  return { type: 'audio', data, mimeType };\n}\n\nexport function fileRefPart(path: string, mimeType?: string): FileRefPart {\n  return { type: 'fileRef', path, mimeType };\n}\n\nexport * from './defineTool.js'; // Export the defineTool helper\nexport * from './typeGuards.js'; // Export type guards and related types\n","import type { ZodTypeAny, z } from 'zod'; // Use import type\nimport type {\n  ToolExecuteOptions,\n  Part,\n  BaseContextSchema, // Import BaseContextSchema\n} from './index';\n// Assuming checkOutputSizeLimit is correctly exported from utils\n// Adjust the import path if utils is structured differently or not directly accessible\n// If utils is not a direct dependency of core, this helper might need to move to core\n// or be passed in somehow. For now, assume it can be imported.\n// import { checkOutputSizeLimit } from './outputUtils.js'; // Removed - Size check moved to Adapter/Server layer\n\n\n/**\n * Defines the structure required to define a tool using the defineTool helper.\n * The context type is inferred from the provided contextSchema.\n * @template TInputSchema Zod schema for input validation.\n * @template TContextSchema Zod schema for context validation. Defaults to BaseContextSchema.\n */\nexport interface ToolDefinition< // Renamed interface for clarity\n  TInputSchema extends ZodTypeAny = z.ZodUndefined,\n  TContextSchema extends ZodTypeAny = typeof BaseContextSchema // Context Schema Generic, defaults to BaseContextSchema\n> {\n  /** Unique name of the tool. */\n  name: string;\n  /** Description of what the tool does. */\n  description: string;\n  /** Zod schema used by the MCP server to validate input arguments. */\n  inputSchema: TInputSchema;\n  /** Zod schema used to validate the context object. */\n  contextSchema: TContextSchema; // Added contextSchema field\n  /**\n   * The core execution logic for the tool.\n   * Receives validated arguments and a context object validated against contextSchema.\n   * Should focus purely on the tool's specific task.\n   */\n  execute: (\n    // Context type is inferred from TContextSchema\n    params: { context: z.infer<TContextSchema>; args: z.infer<TInputSchema> }\n  ) => Promise<Part[]>; // Return Part array directly or throw error\n}\n\n/**\n * A helper function to define a Tool with standardized wrapping logic.\n * This wrapper handles generic error catching.\n * The context type is inferred from the provided contextSchema.\n *\n * @template TInputSchema Zod schema for input validation.\n * @template TContextSchema Zod schema for context validation. Defaults to BaseContextSchema.\n * @param definition An object containing the tool's core properties and execute logic.\n * @returns A fully formed ToolDefinition object with wrapped execution logic.\n */\nexport function defineTool<\n  TInputSchema extends ZodTypeAny = z.ZodUndefined,\n  TContextSchema extends ZodTypeAny = typeof BaseContextSchema // Context Schema Generic\n>(definition: ToolDefinition<TInputSchema, TContextSchema>): ToolDefinition<TInputSchema, TContextSchema> { // Return type uses TContextSchema\n  // Return type matches ToolDefinition interface\n\n  /**\n   * Wrapped execute function that adds common pre- and post-processing.\n   * It receives the context type inferred from the tool definition's contextSchema.\n   */\n  const wrappedExecute = async (\n    // The params object matches the ToolDefinition interface's execute signature\n    params: { context: z.infer<TContextSchema>; args: z.infer<TInputSchema> }\n  ): Promise<Part[]> => {\n    // Return Part array directly\n    // Optional: Add context validation here if desired, though the adapter layer might handle it.\n    // const contextParsed = definition.contextSchema.safeParse(params.context);\n    // if (!contextParsed.success) {\n    //   throw new Error(`Context validation failed: ${contextParsed.error.message}`);\n    // }\n\n    // Removed the try...catch block as it only re-threw the error.\n    // The Adapter layer is responsible for catching errors from the tool execute function.\n    // 1. Call the original, tool-specific execute function with the context and args\n    //    The types inferred from TContextSchema and TInputSchema ensure this call is type-safe.\n    const originalParts = await definition.execute({ context: params.context, args: params.args });\n    // 2. Return the parts array on success\n    return originalParts;\n  };\n\n  // Return the ToolDefinition structure with the wrapped execute function\n  return {\n    name: definition.name,\n    description: definition.description,\n    inputSchema: definition.inputSchema,\n    contextSchema: definition.contextSchema, // Pass contextSchema through\n    execute: wrappedExecute, // Use the wrapped function\n  };\n}\n","import type { ZodTypeAny } from 'zod';\nimport type { AudioPart, FileRefPart, ImagePart, JsonPart, Part, TextPart } from './index.js'; // Assuming Part is exported from core/index.js\n\n// Add type guards for standard Part types if they don't exist\n\nexport function isTextPart(part: Part): part is TextPart {\n    return part.type === 'text';\n}\n\nexport function isJsonPart<T extends ZodTypeAny>(part: Part): part is JsonPart<T> {\n    return part.type === 'json';\n}\n\nexport function isImagePart(part: Part): part is ImagePart {\n    return part.type === 'image';\n}\n\nexport function isAudioPart(part: Part): part is AudioPart {\n    return part.type === 'audio';\n}\n\nexport function isFileRefPart(part: Part): part is FileRefPart {\n    return part.type === 'fileRef';\n}\n\nexport function when<T, J, I, A, F>(part: Part, mapper: {\n    text?: (part: TextPart) => T, // Make handlers optional in the type signature\n    json?: (part: JsonPart) => J,\n    image?: (part: ImagePart) => I,\n    audio?: (part: AudioPart) => A,\n    fileRef?: (part: FileRefPart) => F\n}): T | J | I | A | F | undefined { // Return type remains potentially undefined\n    if (isTextPart(part)) {\n        if (mapper.text) return mapper.text(part);\n        throw new Error(`Handler for part type 'text' not found in mapper`);\n    }\n    if (isJsonPart(part)) {\n        if (mapper.json) return mapper.json(part);\n        throw new Error(`Handler for part type 'json' not found in mapper`);\n    }\n    if (isImagePart(part)) {\n        if (mapper.image) return mapper.image(part);\n        throw new Error(`Handler for part type 'image' not found in mapper`);\n    }\n    if (isAudioPart(part)) {\n        if (mapper.audio) return mapper.audio(part);\n        throw new Error(`Handler for part type 'audio' not found in mapper`);\n    }\n    if (isFileRefPart(part)) {\n        if (mapper.fileRef) return mapper.fileRef(part);\n        throw new Error(`Handler for part type 'fileRef' not found in mapper`);\n    }\n    // This should be unreachable if all part types are handled above\n    throw new Error(`Unhandled part type: ${part.type}`);\n}\n\nexport function mapWhen<T, J, I, A, F>(\n  parts: Part[],\n  mapper: {\n    text?: (part: TextPart) => T | undefined; // Make handlers optional\n    json?: (part: JsonPart) => J | undefined;\n    image?: (part: ImagePart) => I | undefined;\n    audio?: (part: AudioPart) => A | undefined;\n    fileRef?: (part: FileRefPart) => F | undefined;\n  },\n): (T | J | I | A | F)[] {\n  const results: (T | J | I | A | F)[] = [];\n  for (const part of parts) {\n    let result: T | J | I | A | F | undefined;\n    if (isTextPart(part) && mapper.text) {\n      result = mapper.text(part);\n    } else if (isJsonPart(part) && mapper.json) {\n      result = mapper.json(part);\n    } else if (isImagePart(part) && mapper.image) {\n      result = mapper.image(part);\n    } else if (isAudioPart(part) && mapper.audio) {\n      result = mapper.audio(part);\n    } else if (isFileRefPart(part) && mapper.fileRef) {\n      result = mapper.fileRef(part);\n    }\n    // Only add the result if it's not undefined\n    if (result !== undefined) {\n      results.push(result);\n    }\n  }\n  return results;\n}"],"mappings":"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","names":["path"]}