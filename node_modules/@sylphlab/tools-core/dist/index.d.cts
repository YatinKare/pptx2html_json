import { ZodTypeAny, z } from 'zod';

/**
 * Defines the structure required to define a tool using the defineTool helper.
 * The context type is inferred from the provided contextSchema.
 * @template TInputSchema Zod schema for input validation.
 * @template TContextSchema Zod schema for context validation. Defaults to BaseContextSchema.
 */
interface ToolDefinition<// Renamed interface for clarity
TInputSchema extends ZodTypeAny = z.ZodUndefined, TContextSchema extends ZodTypeAny = typeof BaseContextSchema> {
    /** Unique name of the tool. */
    name: string;
    /** Description of what the tool does. */
    description: string;
    /** Zod schema used by the MCP server to validate input arguments. */
    inputSchema: TInputSchema;
    /** Zod schema used to validate the context object. */
    contextSchema: TContextSchema;
    /**
     * The core execution logic for the tool.
     * Receives validated arguments and a context object validated against contextSchema.
     * Should focus purely on the tool's specific task.
     */
    execute: (params: {
        context: z.infer<TContextSchema>;
        args: z.infer<TInputSchema>;
    }) => Promise<Part[]>;
}
/**
 * A helper function to define a Tool with standardized wrapping logic.
 * This wrapper handles generic error catching.
 * The context type is inferred from the provided contextSchema.
 *
 * @template TInputSchema Zod schema for input validation.
 * @template TContextSchema Zod schema for context validation. Defaults to BaseContextSchema.
 * @param definition An object containing the tool's core properties and execute logic.
 * @returns A fully formed ToolDefinition object with wrapped execution logic.
 */
declare function defineTool<TInputSchema extends ZodTypeAny = z.ZodUndefined, TContextSchema extends ZodTypeAny = typeof BaseContextSchema>(definition: ToolDefinition<TInputSchema, TContextSchema>): ToolDefinition<TInputSchema, TContextSchema>;

declare function isTextPart(part: Part): part is TextPart;
declare function isJsonPart<T extends ZodTypeAny>(part: Part): part is JsonPart<T>;
declare function isImagePart(part: Part): part is ImagePart;
declare function isAudioPart(part: Part): part is AudioPart;
declare function isFileRefPart(part: Part): part is FileRefPart;
declare function when<T, J, I, A, F>(part: Part, mapper: {
    text?: (part: TextPart) => T;
    json?: (part: JsonPart) => J;
    image?: (part: ImagePart) => I;
    audio?: (part: AudioPart) => A;
    fileRef?: (part: FileRefPart) => F;
}): T | J | I | A | F | undefined;
declare function mapWhen<T, J, I, A, F>(parts: Part[], mapper: {
    text?: (part: TextPart) => T | undefined;
    json?: (part: JsonPart) => J | undefined;
    image?: (part: ImagePart) => I | undefined;
    audio?: (part: AudioPart) => A | undefined;
    fileRef?: (part: FileRefPart) => F | undefined;
}): (T | J | I | A | F)[];

declare const TextPartSchema: z.ZodObject<{
    type: z.ZodLiteral<"text">;
    value: z.ZodString;
}, "strip", ZodTypeAny, {
    type: "text";
    value: string;
}, {
    type: "text";
    value: string;
}>;
type TextPart = z.infer<typeof TextPartSchema>;
declare const JsonPartSchema: z.ZodObject<{
    type: z.ZodLiteral<"json">;
    value: z.ZodAny;
    schema: z.ZodEffects<z.ZodAny, z.ZodType<any, any, any>, any>;
}, "strip", ZodTypeAny, {
    type: "json";
    schema: z.ZodType<any, any, any>;
    value?: any;
}, {
    type: "json";
    value?: any;
    schema?: any;
}>;
type JsonPart<T extends ZodTypeAny = ZodTypeAny> = {
    type: 'json';
    value: z.infer<T>;
    schema: T;
};
declare const ImagePartSchema: z.ZodObject<{
    type: z.ZodLiteral<"image">;
    data: z.ZodString;
    mimeType: z.ZodString;
}, "strip", ZodTypeAny, {
    type: "image";
    data: string;
    mimeType: string;
}, {
    type: "image";
    data: string;
    mimeType: string;
}>;
type ImagePart = z.infer<typeof ImagePartSchema>;
declare const AudioPartSchema: z.ZodObject<{
    type: z.ZodLiteral<"audio">;
    data: z.ZodString;
    mimeType: z.ZodString;
}, "strip", ZodTypeAny, {
    type: "audio";
    data: string;
    mimeType: string;
}, {
    type: "audio";
    data: string;
    mimeType: string;
}>;
type AudioPart = z.infer<typeof AudioPartSchema>;
declare const FileRefPartSchema: z.ZodObject<{
    type: z.ZodLiteral<"fileRef">;
    path: z.ZodString;
    mimeType: z.ZodOptional<z.ZodString>;
}, "strip", ZodTypeAny, {
    type: "fileRef";
    path: string;
    mimeType?: string | undefined;
}, {
    type: "fileRef";
    path: string;
    mimeType?: string | undefined;
}>;
type FileRefPart = z.infer<typeof FileRefPartSchema>;
declare const PartSchema: z.ZodUnion<[z.ZodObject<{
    type: z.ZodLiteral<"text">;
    value: z.ZodString;
}, "strip", ZodTypeAny, {
    type: "text";
    value: string;
}, {
    type: "text";
    value: string;
}>, z.ZodObject<{
    type: z.ZodLiteral<"json">;
    value: z.ZodAny;
    schema: z.ZodEffects<z.ZodAny, z.ZodType<any, any, any>, any>;
}, "strip", ZodTypeAny, {
    type: "json";
    schema: z.ZodType<any, any, any>;
    value?: any;
}, {
    type: "json";
    value?: any;
    schema?: any;
}>, z.ZodObject<{
    type: z.ZodLiteral<"image">;
    data: z.ZodString;
    mimeType: z.ZodString;
}, "strip", ZodTypeAny, {
    type: "image";
    data: string;
    mimeType: string;
}, {
    type: "image";
    data: string;
    mimeType: string;
}>, z.ZodObject<{
    type: z.ZodLiteral<"audio">;
    data: z.ZodString;
    mimeType: z.ZodString;
}, "strip", ZodTypeAny, {
    type: "audio";
    data: string;
    mimeType: string;
}, {
    type: "audio";
    data: string;
    mimeType: string;
}>, z.ZodObject<{
    type: z.ZodLiteral<"fileRef">;
    path: z.ZodString;
    mimeType: z.ZodOptional<z.ZodString>;
}, "strip", ZodTypeAny, {
    type: "fileRef";
    path: string;
    mimeType?: string | undefined;
}, {
    type: "fileRef";
    path: string;
    mimeType?: string | undefined;
}>]>;
type Part = z.infer<typeof PartSchema>;
declare const ErrorSchema: z.ZodObject<{
    message: z.ZodString;
    suggestion: z.ZodOptional<z.ZodString>;
}, "strip", ZodTypeAny, {
    message: string;
    suggestion?: string | undefined;
}, {
    message: string;
    suggestion?: string | undefined;
}>;
type Error = z.infer<typeof ErrorSchema>;
/** Options passed internally to the tool's execute function by the server */
interface ToolExecuteOptions {
    /** If true, allows the tool to access paths outside the workspace root. Defaults to false. */
    allowOutsideWorkspace?: boolean;
    /** Optional limit on the total character count of the tool's output content. */
    maxOutputChars?: number;
    /** The absolute path to the workspace root directory. */
    workspaceRoot: string;
}
/**
 * Base Zod schema corresponding to ToolExecuteOptions.
 * This serves as the default context schema for tools.
 */
declare const BaseContextSchema: z.ZodObject<{
    allowOutsideWorkspace: z.ZodOptional<z.ZodBoolean>;
    maxOutputChars: z.ZodOptional<z.ZodNumber>;
    workspaceRoot: z.ZodString;
}, "strip", ZodTypeAny, {
    workspaceRoot: string;
    allowOutsideWorkspace?: boolean | undefined;
    maxOutputChars?: number | undefined;
}, {
    workspaceRoot: string;
    allowOutsideWorkspace?: boolean | undefined;
    maxOutputChars?: number | undefined;
}>;
type BaseContext = z.infer<typeof BaseContextSchema>;
interface PathValidationError {
    error: string;
    suggestion: string;
}
/**
 * Resolves a relative path against the workspace root and validates it.
 * By default, prevents resolving paths outside the workspace root.
 *
 * @param relativePathInput The relative path input by the user/tool.
 * @param workspaceRoot The absolute path to the workspace root.
 * @param allowOutsideRoot If true, allows paths outside the workspace root. Defaults to false.
 * @returns The resolved absolute path (string) if valid, or a PathValidationError object if invalid.
 */
declare function validateAndResolvePath(relativePathInput: string, workspaceRoot: string, allowOutsideRoot?: boolean): string | PathValidationError;
declare function textPart(value: string): TextPart;
declare function jsonPart<T extends ZodTypeAny>(value: z.infer<T>, schema: T): JsonPart<T>;
declare function imagePart(data: string, mimeType: string): ImagePart;
declare function audioPart(data: string, mimeType: string): AudioPart;
declare function fileRefPart(path: string, mimeType?: string): FileRefPart;

export { type AudioPart, AudioPartSchema, type BaseContext, BaseContextSchema, type Error, ErrorSchema, type FileRefPart, FileRefPartSchema, type ImagePart, ImagePartSchema, type JsonPart, JsonPartSchema, type Part, PartSchema, type PathValidationError, type TextPart, TextPartSchema, type ToolDefinition, type ToolExecuteOptions, audioPart, defineTool, fileRefPart, imagePart, isAudioPart, isFileRefPart, isImagePart, isJsonPart, isTextPart, jsonPart, mapWhen, textPart, validateAndResolvePath, when };
