// src/index.ts
import path from "node:path";
import { z } from "zod";

// src/defineTool.ts
function defineTool(definition) {
  const wrappedExecute = async (params) => {
    const originalParts = await definition.execute({ context: params.context, args: params.args });
    return originalParts;
  };
  return {
    name: definition.name,
    description: definition.description,
    inputSchema: definition.inputSchema,
    contextSchema: definition.contextSchema,
    // Pass contextSchema through
    execute: wrappedExecute
    // Use the wrapped function
  };
}

// src/typeGuards.ts
function isTextPart(part) {
  return part.type === "text";
}
function isJsonPart(part) {
  return part.type === "json";
}
function isImagePart(part) {
  return part.type === "image";
}
function isAudioPart(part) {
  return part.type === "audio";
}
function isFileRefPart(part) {
  return part.type === "fileRef";
}
function when(part, mapper) {
  if (isTextPart(part)) {
    if (mapper.text) return mapper.text(part);
    throw new Error(`Handler for part type 'text' not found in mapper`);
  }
  if (isJsonPart(part)) {
    if (mapper.json) return mapper.json(part);
    throw new Error(`Handler for part type 'json' not found in mapper`);
  }
  if (isImagePart(part)) {
    if (mapper.image) return mapper.image(part);
    throw new Error(`Handler for part type 'image' not found in mapper`);
  }
  if (isAudioPart(part)) {
    if (mapper.audio) return mapper.audio(part);
    throw new Error(`Handler for part type 'audio' not found in mapper`);
  }
  if (isFileRefPart(part)) {
    if (mapper.fileRef) return mapper.fileRef(part);
    throw new Error(`Handler for part type 'fileRef' not found in mapper`);
  }
  throw new Error(`Unhandled part type: ${part.type}`);
}
function mapWhen(parts, mapper) {
  const results = [];
  for (const part of parts) {
    let result;
    if (isTextPart(part) && mapper.text) {
      result = mapper.text(part);
    } else if (isJsonPart(part) && mapper.json) {
      result = mapper.json(part);
    } else if (isImagePart(part) && mapper.image) {
      result = mapper.image(part);
    } else if (isAudioPart(part) && mapper.audio) {
      result = mapper.audio(part);
    } else if (isFileRefPart(part) && mapper.fileRef) {
      result = mapper.fileRef(part);
    }
    if (result !== void 0) {
      results.push(result);
    }
  }
  return results;
}

// src/index.ts
var TextPartSchema = z.object({ type: z.literal("text"), value: z.string() });
var JsonPartSchema = z.object({
  type: z.literal("json"),
  value: z.any(),
  schema: z.any().refine((val) => val instanceof z.ZodType, { message: "Schema must be a Zod schema instance" })
});
var ImagePartSchema = z.object({
  type: z.literal("image"),
  data: z.string(),
  mimeType: z.string()
});
var AudioPartSchema = z.object({
  type: z.literal("audio"),
  data: z.string(),
  mimeType: z.string()
});
var FileRefPartSchema = z.object({
  type: z.literal("fileRef"),
  path: z.string(),
  mimeType: z.string().optional()
});
var PartSchema = z.union([
  TextPartSchema,
  JsonPartSchema,
  ImagePartSchema,
  AudioPartSchema,
  FileRefPartSchema
]);
var ErrorSchema = z.object({
  message: z.string(),
  suggestion: z.string().optional()
});
var BaseContextSchema = z.object({
  allowOutsideWorkspace: z.boolean().optional(),
  maxOutputChars: z.number().int().positive().optional(),
  workspaceRoot: z.string()
  // Add other base context properties as needed, mirroring ToolExecuteOptions
  // Ensure this stays in sync with ToolExecuteOptions interface
});
function validateAndResolvePath(relativePathInput, workspaceRoot, allowOutsideRoot = false) {
  if (!relativePathInput || relativePathInput.trim() === "") {
    return {
      error: "Path validation failed: Input path cannot be empty.",
      suggestion: "Provide a valid relative path."
    };
  }
  try {
    if (!allowOutsideRoot && path.isAbsolute(relativePathInput)) {
      return {
        error: `Path validation failed: Absolute paths are not allowed. Path: '${relativePathInput}'`,
        suggestion: "Provide a path relative to the workspace root."
      };
    }
    const resolvedPath = path.resolve(workspaceRoot, relativePathInput);
    const relativeToRoot = path.relative(workspaceRoot, resolvedPath);
    if (!allowOutsideRoot) {
      if (!allowOutsideRoot && (relativeToRoot.startsWith("..") || path.isAbsolute(relativeToRoot))) {
        return {
          error: `Path validation failed: Path must resolve within the workspace root ('${workspaceRoot}'). Relative Path: '${relativeToRoot}'`,
          suggestion: `Ensure the path '${relativePathInput}' is relative to the workspace root and does not attempt to go outside it.`
        };
      }
    }
    return resolvedPath;
  } catch (e) {
    const errorMsg = e instanceof Error ? e.message : "Unknown error";
    return {
      error: `Path resolution failed for '${relativePathInput}': ${errorMsg}`,
      suggestion: "Ensure the provided path is valid."
    };
  }
}
function textPart(value) {
  return { type: "text", value };
}
function jsonPart(value, schema) {
  return { type: "json", value, schema };
}
function imagePart(data, mimeType) {
  return { type: "image", data, mimeType };
}
function audioPart(data, mimeType) {
  return { type: "audio", data, mimeType };
}
function fileRefPart(path2, mimeType) {
  return { type: "fileRef", path: path2, mimeType };
}
export {
  AudioPartSchema,
  BaseContextSchema,
  ErrorSchema,
  FileRefPartSchema,
  ImagePartSchema,
  JsonPartSchema,
  PartSchema,
  TextPartSchema,
  audioPart,
  defineTool,
  fileRefPart,
  imagePart,
  isAudioPart,
  isFileRefPart,
  isImagePart,
  isJsonPart,
  isTextPart,
  jsonPart,
  mapWhen,
  textPart,
  validateAndResolvePath,
  when
};
//# sourceMappingURL=index.js.map